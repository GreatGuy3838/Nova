"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReadableStream = exports.getFormats = void 0;
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("./utils");
/**
 * Generates Stream URL(s). Always use this to get streams before getting readable streams!
 */
const getFormats = (formats, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    if (typeof formats !== "object")
        throw new Error(utils_1.constants.err.type("formats", "object", typeof formats));
    if (typeof options !== "object")
        throw new Error(utils_1.constants.err.type("options", "object", typeof options));
    options = utils_1.mergeObj({
        requestOptions: {
            headers: {
                "User-Agent": utils_1.constants.headers.userAgent,
            },
        },
    }, options);
    let streams = [
        ...(formats.formats || []),
        ...(formats.adaptiveFormats || []),
    ].sort((a, b) => (a.bitrate ? +a.bitrate : 0) -
        (b.bitrate ? +b.bitrate : 0) +
        (a.audioSampleRate ? +a.audioSampleRate : 0) -
        (b.audioSampleRate ? +b.audioSampleRate : 0));
    if (options.filterBy) {
        if (typeof options.filterBy === "function") {
            streams = streams.filter(options.filterBy);
        }
        else
            throw new Error(utils_1.constants.err.type("options.filterBy", "function | undefined", typeof options));
    }
    let decodeSignature = null;
    for (const i in streams) {
        let str = streams[i];
        if (((_a = formats.player) === null || _a === void 0 ? void 0 : _a.url) && str.signatureCipher) {
            if (!decodeSignature)
                decodeSignature = yield getCipherFunction(formats.player.url, {
                    requestOptions: options.requestOptions,
                });
            const cipData = {};
            (_c = (_b = str.signatureCipher) === null || _b === void 0 ? void 0 : _b.split("&")) === null || _c === void 0 ? void 0 : _c.forEach((x) => {
                const [k, v] = x.split("=");
                cipData[k] = v;
            });
            str.url = `${decodeURIComponent(cipData.url)}&${cipData.sp}=${decodeSignature(decodeURIComponent(cipData.s))}`;
        }
        str.isLive = !!formats.hlsManifestUrl;
        streams[i] = str;
    }
    if (formats.hlsManifestUrl) {
        const lvstsraw = (yield axios_1.default.get(formats.hlsManifestUrl, Object.assign(Object.assign({}, options.requestOptions), { responseType: "text" }))).data;
        const ifrstart = "EXT-X-STREAM-INF:";
        const lvstscont = lvstsraw
            .split("#")
            .filter((x) => x.startsWith(ifrstart))
            .map((x) => x.split("\n").filter((x) => x.length));
        for (const lvstr of lvstscont) {
            const ifr = lvstr[0]
                .replace(ifrstart, "")
                .split(/,(?=([^\"]*\"[^\"]*\")*[^\"]*$)/g)
                .filter((x) => x)
                .map((x) => x.split("="));
            const res = ifr.find((x) => x[0] === "RESOLUTION");
            const [width, height] = res
                ? (_d = res[1]) === null || _d === void 0 ? void 0 : _d.split("x").map((x) => +x)
                : [0, 0];
            const fps = ifr.find((x) => x[0] === "FRAME-RATE");
            const bandwidth = ifr.find((x) => x[0] === "BANDWIDTH");
            const codecs = ifr.find((x) => x[0] === "CODECS");
            const url = lvstr[1];
            const itag = url.match(/itag\/(\d+)\//);
            streams.push({
                itag: itag ? +itag[1] : 0,
                mimeType: codecs ? `codes=${codecs[1]}` : "",
                contentLength: bandwidth ? bandwidth[1] : "0",
                fps: fps ? +fps[1] : 0,
                height,
                width,
                url,
            });
        }
    }
    return streams.filter((x) => x.url);
});
exports.getFormats = getFormats;
/**
 * Returns a YouTube stream
 *
 * **Info:** Install "m3u8stream" using ` npm install m3u8stream ` for livestream support
 */
const getReadableStream = (streams, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof streams !== "object")
        throw new Error(utils_1.constants.err.type("streams", "object", typeof streams));
    if (typeof options !== "object")
        throw new Error(utils_1.constants.err.type("options", "object", typeof options));
    options = utils_1.mergeObj({
        requestOptions: {
            headers: {
                "User-Agent": utils_1.constants.headers.userAgent,
            },
        },
    }, options);
    if (streams.url.endsWith(".m3u8")) {
        let m3u8;
        try {
            m3u8 = require("m3u8stream");
        }
        catch (err) {
            throw new Error(`Couldn't access "m3u8stream". Have you installed it? (${err})`);
        }
        return m3u8(streams.url, {
            requestOptions: options.requestOptions,
        });
    }
    return (yield axios_1.default.get(streams.url, Object.assign(Object.assign({}, options.requestOptions), { responseType: "stream" }))).data;
});
exports.getReadableStream = getReadableStream;
const getCipherFunction = (url, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _e, _f;
    const res = (yield axios_1.default.get(url, options.requestOptions)).data;
    const mfuncstart = 'a=a.split("")';
    const mfuncend = "};";
    const mfunccont = (_e = res === null || res === void 0 ? void 0 : res.split(mfuncstart)[1]) === null || _e === void 0 ? void 0 : _e.split(mfuncend)[0];
    const mfunc = "(a) => {" + mfuncstart + mfunccont + mfuncend;
    const secvarstart = "var " + ((_f = mfunccont.split(".")[0]) === null || _f === void 0 ? void 0 : _f.replace(";", ""));
    const secvarend = "}};";
    const secfunccont = res === null || res === void 0 ? void 0 : res.split(secvarstart)[1].split(secvarend)[0];
    const secfunc = secvarstart + secfunccont + secvarend;
    const decoder = secfunc + "\n" + mfunc;
    return eval(decoder);
});
